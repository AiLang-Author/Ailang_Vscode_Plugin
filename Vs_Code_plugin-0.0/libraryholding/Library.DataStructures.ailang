// ============================================================================
// AILANG Data Structures Library
// High-Performance, Cache-Aware Data Structures
// ============================================================================

// Memory pools for different data structure types
Pool.DataStructures.HashTables = FixedPool {
    "hash_buckets": ElementType-Address, MaximumLength-1000000,
    "hash_nodes": ElementType-HashNode, MaximumLength-10000000,
    "cache_alignment": Initialize-64, CanChange-False
}

Pool.DataStructures.Trees = DynamicPool {
    "tree_nodes": ElementType-TreeNode, MaximumLength-10000000,
    "node_storage": ElementType-Address, CanChange-True,
    "balance_workspace": ElementType-Address, MaximumLength-1000000
}

Pool.DataStructures.Graphs = DynamicPool {
    "graph_vertices": ElementType-GraphVertex, MaximumLength-1000000,
    "graph_edges": ElementType-GraphEdge, MaximumLength-10000000,
    "adjacency_lists": ElementType-Address, CanChange-True
}

Pool.DataStructures.Heaps = FixedPool {
    "heap_arrays": ElementType-Address, MaximumLength-1000000,
    "priority_elements": ElementType-PriorityElement, MaximumLength-10000000
}

Pool.DataStructures.Cache = TemporalPool {
    "lru_nodes": ElementType-LRUNode, MaximumLength-1000000,
    "cache_entries": ElementType-CacheEntry, MaximumLength-1000000,
    "lifetime": Initialize-"session_scope", CanChange-False
}

// ============================================================================
// Hash Table Implementation
// ============================================================================

HashTableHandle = Record {
    buckets: Array[Address],
    bucket_count: Integer,
    size: Integer,
    load_factor: FloatingPoint,
    hash_function: Function,
    key_type: Text,
    value_type: Text,
    collision_strategy: Text  // "chaining", "open_addressing"
}

HashNode = Record {
    key: Any,
    value: Any,
    hash: UInt64,
    next: OptionalType[HashNode]
}

Function.DataStructures.HashMap.Create {
    Input: (
        initial_capacity: Integer = 16,
        load_factor: FloatingPoint = 0.75,
        key_type: Text = "Any",
        value_type: Text = "Any"
    )
    Output: HashTableHandle
    Body: {
        Pool.DataStructures.HashTables.Allocate(hash_table)
        
        hash_table.bucket_count = initial_capacity
        hash_table.size = 0
        hash_table.load_factor = load_factor
        hash_table.key_type = key_type
        hash_table.value_type = value_type
        hash_table.collision_strategy = "chaining"
        
        // Allocate buckets array
        hash_table.buckets = Array.Create(initial_capacity, Address)
        ForEvery i in Range(0, initial_capacity) {
            hash_table.buckets[i] = Null
        }
        
        // Set appropriate hash function based on key type
        ChoosePath key_type {
            CaseOption "Text": hash_table.hash_function = DataStructures.Hash.String
            CaseOption "Integer": hash_table.hash_function = DataStructures.Hash.Integer
            CaseOption "FloatingPoint": hash_table.hash_function = DataStructures.Hash.Float
            DefaultOption: hash_table.hash_function = DataStructures.Hash.Generic
        }
        
        ReturnValue(hash_table)
    }
}

Function.DataStructures.HashMap.Put {
    Input: (table: HashTableHandle, key: Any, value: Any)
    Body: {
        // Check if resize is needed
        threshold = Multiply(table.bucket_count, table.load_factor)
        IfCondition GreaterThan(table.size, threshold) ThenBlock {
            DataStructures.HashMap.Resize(table, Multiply(table.bucket_count, 2))
        }
        
        hash = Apply(table.hash_function, key)
        bucket_index = Modulo(hash, table.bucket_count)
        
        // Check if key already exists
        current = table.buckets[bucket_index]
        WhileLoop NotEqual(current, Null) {
            IfCondition DataStructures.KeyEquals(current.key, key) ThenBlock {
                current.value = value
                ReturnValue()
            }
            current = current.next
        }
        
        // Create new node
        Pool.DataStructures.HashTables.Allocate(new_node)
        new_node.key = key
        new_node.value = value
        new_node.hash = hash
        new_node.next = table.buckets[bucket_index]
        
        table.buckets[bucket_index] = new_node
        table.size = Add(table.size, 1)
    }
}

Function.DataStructures.HashMap.Get {
    Input: (table: HashTableHandle, key: Any)
    Output: OptionalType[Any]
    Body: {
        hash = Apply(table.hash_function, key)
        bucket_index = Modulo(hash, table.bucket_count)
        
        current = table.buckets[bucket_index]
        WhileLoop NotEqual(current, Null) {
            IfCondition DataStructures.KeyEquals(current.key, key) ThenBlock {
                ReturnValue(current.value)
            }
            current = current.next
        }
        
        ReturnValue(Null)
    }
}

Function.DataStructures.HashMap.Remove {
    Input: (table: HashTableHandle, key: Any)
    Output: Boolean
    Body: {
        hash = Apply(table.hash_function, key)
        bucket_index = Modulo(hash, table.bucket_count)
        
        current = table.buckets[bucket_index]
        previous = Null
        
        WhileLoop NotEqual(current, Null) {
            IfCondition DataStructures.KeyEquals(current.key, key) ThenBlock {
                IfCondition EqualTo(previous, Null) ThenBlock {
                    table.buckets[bucket_index] = current.next
                } ElseBlock {
                    previous.next = current.next
                }
                
                table.size = Subtract(table.size, 1)
                ReturnValue(True)
            }
            previous = current
            current = current.next
        }
        
        ReturnValue(False)
    }
}

Function.DataStructures.HashMap.Resize {
    Input: (table: HashTableHandle, new_capacity: Integer)
    Body: {
        old_buckets = table.buckets
        old_capacity = table.bucket_count
        
        // Create new bucket array
        table.buckets = Array.Create(new_capacity, Address)
        table.bucket_count = new_capacity
        table.size = 0
        
        ForEvery i in Range(0, new_capacity) {
            table.buckets[i] = Null
        }
        
        // Rehash all existing nodes
        ForEvery i in Range(0, old_capacity) {
            current = old_buckets[i]
            WhileLoop NotEqual(current, Null) {
                next = current.next
                DataStructures.HashMap.Put(table, current.key, current.value)
                current = next
            }
        }
    }
}

// ============================================================================
// Binary Search Tree Implementation
// ============================================================================

TreeNode = Record {
    key: Any,
    value: Any,
    left: OptionalType[TreeNode],
    right: OptionalType[TreeNode],
    parent: OptionalType[TreeNode],
    height: Integer,
    color: Text  // For Red-Black trees: "red", "black"
}

BinaryTreeHandle = Record {
    root: OptionalType[TreeNode],
    size: Integer,
    key_type: Text,
    value_type: Text,
    compare_function: Function,
    tree_type: Text  // "bst", "avl", "red_black"
}

Function.DataStructures.BinaryTree.Create {
    Input: (
        key_type: Text = "Any",
        value_type: Text = "Any",
        tree_type: Text = "avl"
    )
    Output: BinaryTreeHandle
    Body: {
        Pool.DataStructures.Trees.Allocate(tree)
        
        tree.root = Null
        tree.size = 0
        tree.key_type = key_type
        tree.value_type = value_type
        tree.tree_type = tree_type
        
        // Set appropriate comparison function
        ChoosePath key_type {
            CaseOption "Integer": tree.compare_function = DataStructures.Compare.Integer
            CaseOption "FloatingPoint": tree.compare_function = DataStructures.Compare.Float
            CaseOption "Text": tree.compare_function = DataStructures.Compare.String
            DefaultOption: tree.compare_function = DataStructures.Compare.Generic
        }
        
        ReturnValue(tree)
    }
}

Function.DataStructures.BinaryTree.Insert {
    Input: (tree: BinaryTreeHandle, key: Any, value: Any)
    Body: {
        IfCondition EqualTo(tree.root, Null) ThenBlock {
            Pool.DataStructures.Trees.Allocate(new_node)
            new_node.key = key
            new_node.value = value
            new_node.left = Null
            new_node.right = Null
            new_node.parent = Null
            new_node.height = 0
            new_node.color = "black"  // Root is always black in RB trees
            
            tree.root = new_node
            tree.size = 1
            ReturnValue()
        }
        
        // Find insertion point
        insertion_point = DataStructures.BinaryTree.FindInsertionPoint(tree, key)
        
        Pool.DataStructures.Trees.Allocate(new_node)
        new_node.key = key
        new_node.value = value
        new_node.left = Null
        new_node.right = Null
        new_node.parent = insertion_point
        new_node.height = 0
        new_node.color = "red"  // New nodes start red in RB trees
        
        comparison = Apply(tree.compare_function, key, insertion_point.key)
        IfCondition LessThan(comparison, 0) ThenBlock {
            insertion_point.left = new_node
        } ElseBlock {
            insertion_point.right = new_node
        }
        
        tree.size = Add(tree.size, 1)
        
        // Rebalance based on tree type
        ChoosePath tree.tree_type {
            CaseOption "avl": DataStructures.AVL.RebalanceAfterInsert(tree, new_node)
            CaseOption "red_black": DataStructures.RedBlack.RebalanceAfterInsert(tree, new_node)
        }
    }
}

Function.DataStructures.BinaryTree.Search {
    Input: (tree: BinaryTreeHandle, key: Any)
    Output: OptionalType[Any]
    Body: {
        current = tree.root
        
        WhileLoop NotEqual(current, Null) {
            comparison = Apply(tree.compare_function, key, current.key)
            
            IfCondition EqualTo(comparison, 0) ThenBlock {
                ReturnValue(current.value)
            } ElseBlock {
                IfCondition LessThan(comparison, 0) ThenBlock {
                    current = current.left
                } ElseBlock {
                    current = current.right
                }
            }
        }
        
        ReturnValue(Null)
    }
}

Function.DataStructures.BinaryTree.Remove {
    Input: (tree: BinaryTreeHandle, key: Any)
    Output: Boolean
    Body: {
        node_to_remove = DataStructures.BinaryTree.FindNode(tree, key)
        IfCondition EqualTo(node_to_remove, Null) ThenBlock {
            ReturnValue(False)
        }
        
        // Handle three cases: no children, one child, two children
        IfCondition And(EqualTo(node_to_remove.left, Null), EqualTo(node_to_remove.right, Null)) ThenBlock {
            // No children - simple removal
            DataStructures.BinaryTree.RemoveLeafNode(tree, node_to_remove)
        } ElseBlock {
            IfCondition Or(EqualTo(node_to_remove.left, Null), EqualTo(node_to_remove.right, Null)) ThenBlock {
                // One child - replace with child
                DataStructures.BinaryTree.RemoveNodeWithOneChild(tree, node_to_remove)
            } ElseBox {
                // Two children - replace with successor
                successor = DataStructures.BinaryTree.FindSuccessor(node_to_remove)
                node_to_remove.key = successor.key
                node_to_remove.value = successor.value
                DataStructures.BinaryTree.RemoveNodeWithOneChild(tree, successor)
            }
        }
        
        tree.size = Subtract(tree.size, 1)
        ReturnValue(True)
    }
}

// ============================================================================
// AVL Tree Balancing
// ============================================================================

Function.DataStructures.AVL.UpdateHeight {
    Input: (node: TreeNode)
    Body: {
        left_height = IfCondition EqualTo(node.left, Null) ThenBlock { -1 } ElseBlock { node.left.height }
        right_height = IfCondition EqualTo(node.right, Null) ThenBlock { -1 } ElseBlock { node.right.height }
        
        node.height = Add(Max(left_height, right_height), 1)
    }
}

Function.DataStructures.AVL.GetBalance {
    Input: (node: TreeNode)
    Output: Integer
    Body: {
        left_height = IfCondition EqualTo(node.left, Null) ThenBlock { -1 } ElseBlock { node.left.height }
        right_height = IfCondition EqualTo(node.right, Null) ThenBlock { -1 } ElseBlock { node.right.height }
        
        ReturnValue(Subtract(left_height, right_height))
    }
}

Function.DataStructures.AVL.RotateLeft {
    Input: (tree: BinaryTreeHandle, node: TreeNode)
    Output: TreeNode
    Body: {
        new_root = node.right
        node.right = new_root.left
        
        IfCondition NotEqual(new_root.left, Null) ThenBlock {
            new_root.left.parent = node
        }
        
        new_root.parent = node.parent
        IfCondition EqualTo(node.parent, Null) ThenBlock {
            tree.root = new_root
        } ElseBlock {
            IfCondition EqualTo(node.parent.left, node) ThenBlock {
                node.parent.left = new_root
            } ElseBlock {
                node.parent.right = new_root
            }
        }
        
        new_root.left = node
        node.parent = new_root
        
        DataStructures.AVL.UpdateHeight(node)
        DataStructures.AVL.UpdateHeight(new_root)
        
        ReturnValue(new_root)
    }
}

Function.DataStructures.AVL.RotateRight {
    Input: (tree: BinaryTreeHandle, node: TreeNode)
    Output: TreeNode
    Body: {
        new_root = node.left
        node.left = new_root.right
        
        IfCondition NotEqual(new_root.right, Null) ThenBlock {
            new_root.right.parent = node
        }
        
        new_root.parent = node.parent
        IfCondition EqualTo(node.parent, Null) ThenBlock {
            tree.root = new_root
        } ElseBlock {
            IfCondition EqualTo(node.parent.left, node) ThenBlock {
                node.parent.left = new_root
            } ElseBlock {
                node.parent.right = new_root
            }
        }
        
        new_root.right = node
        node.parent = new_root
        
        DataStructures.AVL.UpdateHeight(node)
        DataStructures.AVL.UpdateHeight(new_root)
        
        ReturnValue(new_root)
    }
}

Function.DataStructures.AVL.RebalanceAfterInsert {
    Input: (tree: BinaryTreeHandle, node: TreeNode)
    Body: {
        current = node.parent
        
        WhileLoop NotEqual(current, Null) {
            DataStructures.AVL.UpdateHeight(current)
            balance = DataStructures.AVL.GetBalance(current)
            
            // Left-heavy
            IfCondition GreaterThan(balance, 1) ThenBlock {
                left_balance = DataStructures.AVL.GetBalance(current.left)
                
                IfCondition LessThan(left_balance, 0) ThenBlock {
                    // Left-Right case
                    DataStructures.AVL.RotateLeft(tree, current.left)
                }
                
                // Left-Left case
                DataStructures.AVL.RotateRight(tree, current)
                BreakLoop
            }
            
            // Right-heavy
            IfCondition LessThan(balance, -1) ThenBlock {
                right_balance = DataStructures.AVL.GetBalance(current.right)
                
                IfCondition GreaterThan(right_balance, 0) ThenBlock {
                    // Right-Left case
                    DataStructures.AVL.RotateRight(tree, current.right)
                }
                
                // Right-Right case
                DataStructures.AVL.RotateLeft(tree, current)
                BreakLoop
            }
            
            current = current.parent
        }
    }
}

// ============================================================================
// Priority Queue (Binary Heap) Implementation
// ============================================================================

PriorityElement = Record {
    value: Any,
    priority: FloatingPoint
}

HeapHandle = Record {
    elements: Array[PriorityElement],
    size: Integer,
    capacity: Integer,
    heap_type: Text,  // "min_heap", "max_heap"
    compare_function: Function
}

Function.DataStructures.PriorityQueue.Create {
    Input: (
        initial_capacity: Integer = 16,
        heap_type: Text = "min_heap"
    )
    Output: HeapHandle
    Body: {
        Pool.DataStructures.Heaps.Allocate(heap)
        
        heap.elements = Array.Create(initial_capacity, PriorityElement)
        heap.size = 0
        heap.capacity = initial_capacity
        heap.heap_type = heap_type
        
        ChoosePath heap_type {
            CaseOption "min_heap": heap.compare_function = DataStructures.Compare.MinHeap
            CaseOption "max_heap": heap.compare_function = DataStructures.Compare.MaxHeap
            DefaultOption: heap.compare_function = DataStructures.Compare.MinHeap
        }
        
        ReturnValue(heap)
    }
}

Function.DataStructures.PriorityQueue.Push {
    Input: (heap: HeapHandle, value: Any, priority: FloatingPoint)
    Body: {
        // Resize if needed
        IfCondition EqualTo(heap.size, heap.capacity) ThenBlock {
            DataStructures.PriorityQueue.Resize(heap, Multiply(heap.capacity, 2))
        }
        
        // Insert at end and bubble up
        element = PriorityElement.Create()
        element.value = value
        element.priority = priority
        
        heap.elements[heap.size] = element
        heap.size = Add(heap.size, 1)
        
        DataStructures.PriorityQueue.BubbleUp(heap, Subtract(heap.size, 1))
    }
}

Function.DataStructures.PriorityQueue.Pop {
    Input: (heap: HeapHandle)
    Output: OptionalType[Any]
    Body: {
        IfCondition EqualTo(heap.size, 0) ThenBlock {
            ReturnValue(Null)
        }
        
        top_element = heap.elements[0].value
        
        // Move last element to top and bubble down
        heap.elements[0] = heap.elements[Subtract(heap.size, 1)]
        heap.size = Subtract(heap.size, 1)
        
        IfCondition GreaterThan(heap.size, 0) ThenBlock {
            DataStructures.PriorityQueue.BubbleDown(heap, 0)
        }
        
        ReturnValue(top_element)
    }
}

Function.DataStructures.PriorityQueue.Peek {
    Input: (heap: HeapHandle)
    Output: OptionalType[Any]
    Body: {
        IfCondition EqualTo(heap.size, 0) ThenBlock {
            ReturnValue(Null)
        }
        
        ReturnValue(heap.elements[0].value)
    }
}

Function.DataStructures.PriorityQueue.BubbleUp {
    Input: (heap: HeapHandle, index: Integer)
    Body: {
        IfCondition EqualTo(index, 0) ThenBlock {
            ReturnValue()
        }
        
        parent_index = Divide(Subtract(index, 1), 2)
        
        should_swap = Apply(
            heap.compare_function,
            heap.elements[index].priority,
            heap.elements[parent_index].priority
        )
        
        IfCondition should_swap ThenBlock {
            DataStructures.Swap(heap.elements, index, parent_index)
            DataStructures.PriorityQueue.BubbleUp(heap, parent_index)
        }
    }
}

Function.DataStructures.PriorityQueue.BubbleDown {
    Input: (heap: HeapHandle, index: Integer)
    Body: {
        left_child = Add(Multiply(index, 2), 1)
        right_child = Add(Multiply(index, 2), 2)
        target_index = index
        
        // Find the highest priority child
        IfCondition LessThan(left_child, heap.size) ThenBlock {
            should_swap = Apply(
                heap.compare_function,
                heap.elements[left_child].priority,
                heap.elements[target_index].priority
            )
            IfCondition should_swap ThenBlock {
                target_index = left_child
            }
        }
        
        IfCondition LessThan(right_child, heap.size) ThenBlock {
            should_swap = Apply(
                heap.compare_function,
                heap.elements[right_child].priority,
                heap.elements[target_index].priority
            )
            IfCondition should_swap ThenBlock {
                target_index = right_child
            }
        }
        
        IfCondition NotEqual(target_index, index) ThenBlock {
            DataStructures.Swap(heap.elements, index, target_index)
            DataStructures.PriorityQueue.BubbleDown(heap, target_index)
        }
    }
}

// ============================================================================
// LRU Cache Implementation
// ============================================================================

LRUNode = Record {
    key: Any,
    value: Any,
    prev: OptionalType[LRUNode],
    next: OptionalType[LRUNode]
}

LRUCacheHandle = Record {
    capacity: Integer,
    size: Integer,
    hash_table: HashTableHandle,
    head: LRUNode,
    tail: LRUNode
}

Function.DataStructures.LRUCache.Create {
    Input: (capacity: Integer)
    Output: LRUCacheHandle
    Body: {
        Pool.DataStructures.Cache.Allocate(cache)
        
        cache.capacity = capacity
        cache.size = 0
        cache.hash_table = DataStructures.HashMap.Create(capacity)
        
        // Create dummy head and tail nodes
        Pool.DataStructures.Cache.Allocate(cache.head)
        Pool.DataStructures.Cache.Allocate(cache.tail)
        
        cache.head.next = cache.tail
        cache.tail.prev = cache.head
        
        ReturnValue(cache)
    }
}

Function.DataStructures.LRUCache.Get {
    Input: (cache: LRUCacheHandle, key: Any)
    Output: OptionalType[Any]
    Body: {
        node = DataStructures.HashMap.Get(cache.hash_table, key)
        
        IfCondition EqualTo(node, Null) ThenBlock {
            ReturnValue(Null)
        }
        
        // Move to front (most recently used)
        DataStructures.LRUCache.MoveToFront(cache, node)
        
        ReturnValue(node.value)
    }
}

Function.DataStructures.LRUCache.Put {
    Input: (cache: LRUCacheHandle, key: Any, value: Any)
    Body: {
        existing_node = DataStructures.HashMap.Get(cache.hash_table, key)
        
        IfCondition NotEqual(existing_node, Null) ThenBlock {
            // Update existing node
            existing_node.value = value
            DataStructures.LRUCache.MoveToFront(cache, existing_node)
            ReturnValue()
        }
        
        // Create new node
        Pool.DataStructures.Cache.Allocate(new_node)
        new_node.key = key
        new_node.value = value
        
        // Add to hash table and front of list
        DataStructures.HashMap.Put(cache.hash_table, key, new_node)
        DataStructures.LRUCache.AddToFront(cache, new_node)
        cache.size = Add(cache.size, 1)
        
        // Evict if over capacity
        IfCondition GreaterThan(cache.size, cache.capacity) ThenBlock {
            DataStructures.LRUCache.EvictLeastUsed(cache)
        }
    }
}

Function.DataStructures.LRUCache.MoveToFront {
    Input: (cache: LRUCacheHandle, node: LRUNode)
    Body: {
        // Remove from current position
        node.prev.next = node.next
        node.next.prev = node.prev
        
        // Add to front
        DataStructures.LRUCache.AddToFront(cache, node)
    }
}

Function.DataStructures.LRUCache.AddToFront {
    Input: (cache: LRUCacheHandle, node: LRUNode)
    Body: {
        node.next = cache.head.next
        node.prev = cache.head
        cache.head.next.prev = node
        cache.head.next = node
    }
}

Function.DataStructures.LRUCache.EvictLeastUsed {
    Input: (cache: LRUCacheHandle)
    Body: {
        last_node = cache.tail.prev
        
        // Remove from hash table
        DataStructures.HashMap.Remove(cache.hash_table, last_node.key)
        
        // Remove from doubly linked list
        last_node.prev.next = cache.tail
        cache.tail.prev = last_node.prev
        
        cache.size = Subtract(cache.size, 1)
    }
}

// ============================================================================
// Graph Implementation
// ============================================================================

GraphVertex = Record {
    id: Any,
    data: Any,
    adjacency_list: Array[GraphEdge],
    visited: Boolean,
    distance: FloatingPoint,
    parent: OptionalType[GraphVertex]
}

GraphEdge = Record {
    from_vertex: GraphVertex,
    to_vertex: GraphVertex,
    weight: FloatingPoint,
    data: Any
}

GraphHandle = Record {
    vertices: Map[Any, GraphVertex],
    edges: Array[GraphEdge],
    vertex_count: Integer,
    edge_count: Integer,
    directed: Boolean
}

Function.DataStructures.Graph.Create {
    Input: (directed: Boolean = True)
    Output: GraphHandle
    Body: {
        Pool.DataStructures.Graphs.Allocate(graph)
        
        graph.vertices = DataStructures.HashMap.Create()
        graph.edges = Array.Create()
        graph.vertex_count = 0
        graph.edge_count = 0
        graph.directed = directed
        
        ReturnValue(graph)
    }
}

Function.DataStructures.Graph.AddVertex {
    Input: (graph: GraphHandle, id: Any, data: Any = Null)
    Body: {
        IfCondition DataStructures.HashMap.Get(graph.vertices, id) != Null ThenBlock {
            ReturnValue()  // Vertex already exists
        }
        
        Pool.DataStructures.Graphs.Allocate(vertex)
        vertex.id = id
        vertex.data = data
        vertex.adjacency_list = Array.Create()
        vertex.visited = False
        vertex.distance = FloatingPoint.Infinity
        vertex.parent = Null
        
        DataStructures.HashMap.Put(graph.vertices, id, vertex)
        graph.vertex_count = Add(graph.vertex_count, 1)
    }
}

Function.DataStructures.Graph.AddEdge {
    Input: (
        graph: GraphHandle,
        from_id: Any,
        to_id: Any,
        weight: FloatingPoint = 1.0,
        data: Any = Null
    )
    Body: {
        from_vertex = DataStructures.HashMap.Get(graph.vertices, from_id)
        to_vertex = DataStructures.HashMap.Get(graph.vertices, to_id)
        
        IfCondition Or(EqualTo(from_vertex, Null), EqualTo(to_vertex, Null)) ThenBlock {
            TryBlock: {} CatchError.VertexNotFound {}
        }
        
        Pool.DataStructures.Graphs.Allocate(edge)
        edge.from_vertex = from_vertex
        edge.to_vertex = to_vertex
        edge.weight = weight
        edge.data = data
        
        Array.Push(from_vertex.adjacency_list, edge)
        Array.Push(graph.edges, edge)
        graph.edge_count = Add(graph.edge_count, 1)
        
        // For undirected graphs, add reverse edge
        IfCondition Not(graph.directed) ThenBlock {
            Pool.DataStructures.Graphs.Allocate(reverse_edge)
            reverse_edge.from_vertex = to_vertex
            reverse_edge.to_vertex = from_vertex
            reverse_edge.weight = weight
            reverse_edge.data = data
            
            Array.Push(to_vertex.adjacency_list, reverse_edge)
        }
    }
}

Function.DataStructures.Graph.BFS {
    Input: (graph: GraphHandle, start_id: Any)
    Output: Array[Any]  // Vertex IDs in BFS order
    Body: {
        // Reset all vertices
        ForEvery vertex_id in DataStructures.HashMap.Keys(graph.vertices) {
            vertex = DataStructures.HashMap.Get(graph.vertices, vertex_id)
            vertex.visited = False
            vertex.distance = FloatingPoint.Infinity
            vertex.parent = Null
        }
        
        start_vertex = DataStructures.HashMap.Get(graph.vertices, start_id)
        IfCondition EqualTo(start_vertex, Null) ThenBlock {
            ReturnValue(Array.Create())
        }
        
        result = Array.Create()
        queue = DataStructures.Queue.Create()
        
        start_vertex.visited = True
        start_vertex.distance = 0.0
        DataStructures.Queue.Push(queue, start_vertex)
        
        WhileLoop Not(DataStructures.Queue.IsEmpty(queue)) {
            current_vertex = DataStructures.Queue.Pop(queue)
            Array.Push(result, current_vertex.id)
            
            ForEvery edge in current_vertex.adjacency_list {
                neighbor = edge.to_vertex
                
                IfCondition Not(neighbor.visited) ThenBlock {
                    neighbor.visited = True
                    neighbor.distance = Add(current_vertex.distance, 1.0)
                    neighbor.parent = current_vertex
                    DataStructures.Queue.Push(queue, neighbor)
                }
            }
        }
        
        ReturnValue(result)
    }
}

Function.DataStructures.Graph.DFS {
    Input: (graph: GraphHandle, start_id: Any)
    Output: Array[Any]  // Vertex IDs in DFS order
    Body: {
        // Reset all vertices
        ForEvery vertex_id in DataStructures.HashMap.Keys(graph.vertices) {
            vertex = DataStructures.HashMap.Get(graph.vertices, vertex_id)
            vertex.visited = False
        }
        
        start_vertex = DataStructures.HashMap.Get(graph.vertices, start_id)
        IfCondition EqualTo(start_vertex, Null) ThenBlock {
            ReturnValue(Array.Create())
        }
        
        result = Array.Create()
        DataStructures.Graph.DFSRecursive(start_vertex, result)
        
        ReturnValue(result)
    }
}

Function.DataStructures.Graph.DFSRecursive {
    Input: (vertex: GraphVertex, result: Array[Any])
    Body: {
        vertex.visited = True
        Array.Push(result, vertex.id)
        
        ForEvery edge in vertex.adjacency_list {
            neighbor = edge.to_vertex
            IfCondition Not(neighbor.visited) ThenBlock {
                DataStructures.Graph.DFSRecursive(neighbor, result)
            }
        }
    }
}

Function.DataStructures.Graph.Dijkstra {
    Input: (graph: GraphHandle, start_id: Any)
    Output: Map[Any, FloatingPoint]  // Vertex ID to shortest distance
    Body: {
        // Initialize all vertices
        ForEvery vertex_id in DataStructures.HashMap.Keys(graph.vertices) {
            vertex = DataStructures.HashMap.Get(graph.vertices, vertex_id)
            vertex.distance = FloatingPoint.Infinity
            vertex.visited = False
            vertex.parent = Null
        }
        
        start_vertex = DataStructures.HashMap.Get(graph.vertices, start_id)
        IfCondition EqualTo(start_vertex, Null) ThenBlock {
            ReturnValue(DataStructures.HashMap.Create())
        }
        
        start_vertex.distance = 0.0
        
        // Use priority queue for unvisited vertices
        pq = DataStructures.PriorityQueue.Create(heap_type-"min_heap")
        DataStructures.PriorityQueue.Push(pq, start_vertex, 0.0)
        
        distances = DataStructures.HashMap.Create()
        
        WhileLoop Not(DataStructures.PriorityQueue.IsEmpty(pq)) {
            current_vertex = DataStructures.PriorityQueue.Pop(pq)
            
            IfCondition current_vertex.visited ThenBlock {
                ContinueLoop
            }
            
            current_vertex.visited = True
            DataStructures.HashMap.Put(distances, current_vertex.id, current_vertex.distance)
            
            ForEvery edge in current_vertex.adjacency_list {
                neighbor = edge.to_vertex
                
                IfCondition Not(neighbor.visited) ThenBlock {
                    new_distance = Add(current_vertex.distance, edge.weight)
                    
                    IfCondition LessThan(new_distance, neighbor.distance) ThenBlock {
                        neighbor.distance = new_distance
                        neighbor.parent = current_vertex
                        DataStructures.PriorityQueue.Push(pq, neighbor, new_distance)
                    }
                }
            }
        }
        
        ReturnValue(distances)
    }
}

// ============================================================================
// Utility Functions
// ============================================================================

Function.DataStructures.Hash.String {
    Input: (str: Text)
    Output: UInt64
    Body: {
        hash = UInt64(5381)
        
        ForEvery char in StringToCharArray(str) {
            hash = Add(Multiply(hash, 33), CharToCode(char))
        }
        
        ReturnValue(hash)
    }
}

Function.DataStructures.Hash.Integer {
    Input: (num: Integer)
    Output: UInt64
    Body: {
        // Simple integer hash using multiplication and bit shifting
        hash = UInt64(num)
        hash = BitwiseXor(hash, RightShift(hash, 16))
        hash = Multiply(hash, 0x85ebca6b)
        hash = BitwiseXor(hash, RightShift(hash, 13))
        hash = Multiply(hash, 0xc2b2ae35)
        hash = BitwiseXor(hash, RightShift(hash, 16))
        
        ReturnValue(hash)
    }
}

Function.DataStructures.Hash.Float {
    Input: (num: FloatingPoint)
    Output: UInt64
    Body: {
        // Convert float to integer representation and hash
        int_bits = FloatToBits(num)
        ReturnValue(DataStructures.Hash.Integer(int_bits))
    }
}

Function.DataStructures.Hash.Generic {
    Input: (obj: Any)
    Output: UInt64
    Body: {
        // Generic hash based on object's memory address
        // In a real implementation, this would use reflection
        addr = GetObjectAddress(obj)
        ReturnValue(DataStructures.Hash.Integer(addr))
    }
}

Function.DataStructures.KeyEquals {
    Input: (key1: Any, key2: Any)
    Output: Boolean
    Body: {
        // Type-specific equality comparison
        IfCondition NotEqual(GetType(key1), GetType(key2)) ThenBlock {
            ReturnValue(False)
        }
        
        type_name = GetTypeName(key1)
        
        ChoosePath type_name {
            CaseOption "Text": ReturnValue(StringEquals(key1, key2))
            CaseOption "Integer": ReturnValue(EqualTo(key1, key2))
            CaseOption "FloatingPoint": ReturnValue(EqualTo(key1, key2))
            DefaultOption: ReturnValue(EqualTo(GetObjectAddress(key1), GetObjectAddress(key2)))
        }
    }
}

Function.DataStructures.Compare.Integer {
    Input: (a: Integer, b: Integer)
    Output: Integer
    Body: {
        IfCondition LessThan(a, b) ThenBlock {
            ReturnValue(-1)
        } ElseBlock {
            IfCondition GreaterThan(a, b) ThenBlock {
                ReturnValue(1)
            } ElseBlock {
                ReturnValue(0)
            }
        }
    }
}

Function.DataStructures.Compare.Float {
    Input: (a: FloatingPoint, b: FloatingPoint)
    Output: Integer
    Body: {
        epsilon = 1e-9
        diff = Subtract(a, b)
        
        IfCondition LessThan(AbsoluteValue(diff), epsilon) ThenBlock {
            ReturnValue(0)
        } ElseBlock {
            IfCondition LessThan(a, b) ThenBlock {
                ReturnValue(-1)
            } ElseBlock {
                ReturnValue(1)
            }
        }
    }
}

Function.DataStructures.Compare.String {
    Input: (a: Text, b: Text)
    Output: Integer
    Body: {
        ReturnValue(StringCompare(a, b))
    }
}

Function.DataStructures.Compare.MinHeap {
    Input: (a: FloatingPoint, b: FloatingPoint)
    Output: Boolean
    Body: {
        ReturnValue(LessThan(a, b))
    }
}

Function.DataStructures.Compare.MaxHeap {
    Input: (a: FloatingPoint, b: FloatingPoint)
    Output: Boolean
    Body: {
        ReturnValue(GreaterThan(a, b))
    }
}

Function.DataStructures.Swap {
    Input: (array: Array[Any], i: Integer, j: Integer)
    Body: {
        temp = array[i]
        array[i] = array[j]
        array[j] = temp
    }
}

// ============================================================================
// Queue Implementation (for BFS)
// ============================================================================

QueueHandle = Record {
    items: Array[Any],
    front: Integer,
    rear: Integer,
    size: Integer,
    capacity: Integer
}

Function.DataStructures.Queue.Create {
    Input: (initial_capacity: Integer = 16)
    Output: QueueHandle
    Body: {
        queue = QueueHandle.Create()
        queue.items = Array.Create(initial_capacity, Any)
        queue.front = 0
        queue.rear = 0
        queue.size = 0
        queue.capacity = initial_capacity
        
        ReturnValue(queue)
    }
}

Function.DataStructures.Queue.Push {
    Input: (queue: QueueHandle, item: Any)
    Body: {
        IfCondition EqualTo(queue.size, queue.capacity) ThenBlock {
            DataStructures.Queue.Resize(queue, Multiply(queue.capacity, 2))
        }
        
        queue.items[queue.rear] = item
        queue.rear = Modulo(Add(queue.rear, 1), queue.capacity)
        queue.size = Add(queue.size, 1)
    }
}

Function.DataStructures.Queue.Pop {
    Input: (queue: QueueHandle)
    Output: OptionalType[Any]
    Body: {
        IfCondition EqualTo(queue.size, 0) ThenBlock {
            ReturnValue(Null)
        }
        
        item = queue.items[queue.front]
        queue.front = Modulo(Add(queue.front, 1), queue.capacity)
        queue.size = Subtract(queue.size, 1)
        
        ReturnValue(item)
    }
}

Function.DataStructures.Queue.IsEmpty {
    Input: (queue: QueueHandle)
    Output: Boolean
    Body: {
        ReturnValue(EqualTo(queue.size, 0))
    }
}

Function.DataStructures.Queue.Resize {
    Input: (queue: QueueHandle, new_capacity: Integer)
    Body: {
        new_items = Array.Create(new_capacity, Any)
        
        ForEvery i in Range(0, queue.size) {
            index = Modulo(Add(queue.front, i), queue.capacity)
            new_items[i] = queue.items[index]
        }
        
        queue.items = new_items
        queue.front = 0
        queue.rear = queue.size
        queue.capacity = new_capacity
    }
}

// ============================================================================
// Performance Monitoring
// ============================================================================

Function.DataStructures.Performance.GetHashTableStats {
    Input: (table: HashTableHandle)
    Output: HashTableStats
    Body: {
        stats = HashTableStats.Create()
        stats.size = table.size
        stats.bucket_count = table.bucket_count
        stats.load_factor = Divide(table.size, table.bucket_count)
        
        // Calculate collision statistics
        empty_buckets = 0
        max_chain_length = 0
        total_chain_length = 0
        
        ForEvery i in Range(0, table.bucket_count) {
            IfCondition EqualTo(table.buckets[i], Null) ThenBlock {
                empty_buckets = Add(empty_buckets, 1)
            } ElseBlock {
                chain_length = 0
                current = table.buckets[i]
                
                WhileLoop NotEqual(current, Null) {
                    chain_length = Add(chain_length, 1)
                    current = current.next
                }
                
                max_chain_length = Max(max_chain_length, chain_length)
                total_chain_length = Add(total_chain_length, chain_length)
            }
        }
        
        stats.empty_buckets = empty_buckets
        stats.max_chain_length = max_chain_length
        stats.average_chain_length = Divide(total_chain_length, Subtract(table.bucket_count, empty_buckets))
        
        ReturnValue(stats)
    }
}