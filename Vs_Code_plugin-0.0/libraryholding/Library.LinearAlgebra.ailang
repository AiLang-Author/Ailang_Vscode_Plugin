// ============================================================================
// AILANG Linear Algebra Library
// High-Performance, Cache-Aware Linear Algebra Operations
// ============================================================================

// Memory pools for different linear algebra workloads
Pool.LinearAlgebra.SmallVectors = FixedPool {
    "vector_storage": ElementType-FloatingPoint, MaximumLength-100000,
    "cache_policy": Initialize-"L1", CanChange-False
}

Pool.LinearAlgebra.LargeMatrices = DynamicPool {
    "matrix_storage": ElementType-FloatingPoint, CanChange-True,
    "cache_policy": Initialize-"L3", CanChange-False,
    "numa_aware": Initialize-True, CanChange-False
}

Pool.LinearAlgebra.TemporaryWorkspace = TemporalPool {
    "temp_data": ElementType-FloatingPoint, MaximumLength-1000000,
    "lifetime": Initialize-"function_scope", CanChange-False
}

Pool.LinearAlgebra.EigenWorkspace = TemporalPool {
    "eigen_data": ElementType-FloatingPoint, MaximumLength-10000000,
    "lifetime": Initialize-"algorithm_scope", CanChange-False
}

// ============================================================================
// Core Data Types
// ============================================================================

// Vector types
Vector2f = Record {
    data: Array[FloatingPoint, 2],
    cache_line: UInt8
}

Vector3f = Record {
    data: Array[FloatingPoint, 3],
    cache_line: UInt8
}

Vector4f = Record {
    data: Array[FloatingPoint, 4], 
    cache_line: UInt8
}

VectorXf = Record {
    data: Array[FloatingPoint],
    size: Integer,
    capacity: Integer,
    pool_id: Address
}

// Matrix types
Matrix2f = Record {
    data: Array[FloatingPoint, 4],
    rows: Integer = 2,
    cols: Integer = 2,
    cache_aligned: Boolean = True
}

Matrix3f = Record {
    data: Array[FloatingPoint, 9],
    rows: Integer = 3,
    cols: Integer = 3,
    cache_aligned: Boolean = True
}

Matrix4f = Record {
    data: Array[FloatingPoint, 16],
    rows: Integer = 4,
    cols: Integer = 4,
    cache_aligned: Boolean = True
}

MatrixXf = Record {
    data: Array[FloatingPoint],
    rows: Integer,
    cols: Integer,
    stride: Integer,
    pool_id: Address,
    storage_order: Text = "column_major"
}

SparseMatrix = Record {
    values: Array[FloatingPoint],
    row_indices: Array[Integer],
    col_pointers: Array[Integer],
    rows: Integer,
    cols: Integer,
    nnz: Integer
}

// ============================================================================
// Vector Operations
// ============================================================================

Function.Vector.Create {
    Input: (size: Integer, initial_value: FloatingPoint = 0.0)
    Output: VectorXf
    Body: {
        Pool.LinearAlgebra.SmallVectors.Allocate(vector)
        vector.size = size
        vector.capacity = size
        vector.pool_id = Pool.LinearAlgebra.SmallVectors.GetAddress()
        
        ForEvery i in Range(0, size) {
            vector.data[i] = initial_value
        }
        
        ReturnValue(vector)
    }
}

Function.Vector.CreateFixed2 {
    Input: (x: FloatingPoint, y: FloatingPoint)
    Output: Vector2f
    Body: {
        vector = Vector2f.Create()
        vector.data[0] = x
        vector.data[1] = y
        vector.cache_line = 0
        
        ReturnValue(vector)
    }
}

Function.Vector.CreateFixed3 {
    Input: (x: FloatingPoint, y: FloatingPoint, z: FloatingPoint)
    Output: Vector3f
    Body: {
        vector = Vector3f.Create()
        vector.data[0] = x
        vector.data[1] = y
        vector.data[2] = z
        vector.cache_line = 0
        
        ReturnValue(vector)
    }
}

Function.Vector.Dot {
    Input: (a: VectorXf, b: VectorXf)
    Output: FloatingPoint
    Body: {
        IfCondition NotEqual(a.size, b.size) ThenBlock {
            TryBlock: {} CatchError.DimensionMismatch {
                PrintMessage("Vector dimensions must match for dot product")
                ReturnValue(0.0)
            }
        }
        
        // Cache-aware dot product with prefetching
        Cache.L1.Prefetch(a.data, size-Multiply(a.size, 8))
        Cache.L1.Prefetch(b.data, size-Multiply(b.size, 8))
        
        result = 0.0
        
        // Vectorized loop with cache awareness
        ForEvery i in Range(0, a.size) {
            result = Add(result, Multiply(a.data[i], b.data[i]))
        }
        
        ReturnValue(result)
    }
}

Function.Vector.Cross3 {
    Input: (a: Vector3f, b: Vector3f)
    Output: Vector3f
    Body: {
        result = Vector3f.Create()
        
        result.data[0] = Subtract(
            Multiply(a.data[1], b.data[2]),
            Multiply(a.data[2], b.data[1])
        )
        result.data[1] = Subtract(
            Multiply(a.data[2], b.data[0]),
            Multiply(a.data[0], b.data[2])
        )
        result.data[2] = Subtract(
            Multiply(a.data[0], b.data[1]),
            Multiply(a.data[1], b.data[0])
        )
        
        ReturnValue(result)
    }
}

Function.Vector.Normalize {
    Input: (v: VectorXf)
    Output: VectorXf
    Body: {
        norm = SquareRoot(Vector.Dot(v, v))
        
        IfCondition LessEqual(norm, 1e-10) ThenBlock {
            ReturnValue(Vector.Create(v.size, 0.0))
        }
        
        result = Vector.Create(v.size)
        
        ForEvery i in Range(0, v.size) {
            result.data[i] = Divide(v.data[i], norm)
        }
        
        ReturnValue(result)
    }
}

Function.Vector.Add {
    Input: (a: VectorXf, b: VectorXf)
    Output: VectorXf
    Body: {
        IfCondition NotEqual(a.size, b.size) ThenBlock {
            TryBlock: {} CatchError.DimensionMismatch {}
        }
        
        result = Vector.Create(a.size)
        
        ForEvery i in Range(0, a.size) {
            result.data[i] = Add(a.data[i], b.data[i])
        }
        
        ReturnValue(result)
    }
}

Function.Vector.Scale {
    Input: (v: VectorXf, scalar: FloatingPoint)
    Output: VectorXf
    Body: {
        result = Vector.Create(v.size)
        
        ForEvery i in Range(0, v.size) {
            result.data[i] = Multiply(v.data[i], scalar)
        }
        
        ReturnValue(result)
    }
}

// ============================================================================
// Matrix Operations
// ============================================================================

Function.Matrix.Create {
    Input: (rows: Integer, cols: Integer, initial_value: FloatingPoint = 0.0)
    Output: MatrixXf
    Body: {
        total_size = Multiply(rows, cols)
        
        IfCondition LessEqual(total_size, 10000) ThenBlock {
            Pool.LinearAlgebra.SmallVectors.Allocate(matrix, size-Multiply(total_size, 8))
        } ElseBlock {
            Pool.LinearAlgebra.LargeMatrices.Allocate(matrix, size-Multiply(total_size, 8))
        }
        
        matrix.rows = rows
        matrix.cols = cols
        matrix.stride = cols  // Column-major default
        
        ForEvery i in Range(0, total_size) {
            matrix.data[i] = initial_value
        }
        
        ReturnValue(matrix)
    }
}

Function.Matrix.Identity {
    Input: (size: Integer)
    Output: MatrixXf
    Body: {
        result = Matrix.Create(size, size, 0.0)
        
        ForEvery i in Range(0, size) {
            result.data[Add(Multiply(i, size), i)] = 1.0
        }
        
        ReturnValue(result)
    }
}

Function.Matrix.Get {
    Input: (matrix: MatrixXf, row: Integer, col: Integer)
    Output: FloatingPoint
    Body: {
        IfCondition Or(
            GreaterEqual(row, matrix.rows),
            GreaterEqual(col, matrix.cols)
        ) ThenBlock {
            TryBlock: {} CatchError.IndexOutOfBounds {}
        }
        
        index = Add(Multiply(col, matrix.stride), row)
        ReturnValue(matrix.data[index])
    }
}

Function.Matrix.Set {
    Input: (matrix: MatrixXf, row: Integer, col: Integer, value: FloatingPoint)
    Body: {
        IfCondition Or(
            GreaterEqual(row, matrix.rows),
            GreaterEqual(col, matrix.cols)
        ) ThenBlock {
            TryBlock: {} CatchError.IndexOutOfBounds {}
        }
        
        index = Add(Multiply(col, matrix.stride), row)
        matrix.data[index] = value
    }
}

Function.Matrix.Multiply {
    Input: (A: MatrixXf, B: MatrixXf)
    Output: MatrixXf
    Body: {
        IfCondition NotEqual(A.cols, B.rows) ThenBlock {
            TryBlock: {} CatchError.DimensionMismatch {}
        }
        
        // Cache-blocked matrix multiplication
        block_size = 64  // Tuned for L1 cache
        C = Matrix.Create(A.rows, B.cols)
        
        // Allocate temporary workspace
        Pool.LinearAlgebra.TemporaryWorkspace.Allocate(temp_block, size-Multiply(block_size, Multiply(block_size, 8)))
        
        ForEvery i_block in Range(0, A.rows, block_size) {
            ForEvery j_block in Range(0, B.cols, block_size) {
                ForEvery k_block in Range(0, A.cols, block_size) {
                    
                    // Cache-friendly block multiplication
                    Matrix.MultiplyBlock(
                        A, B, C,
                        i_start-i_block, j_start-j_block, k_start-k_block,
                        block_size-block_size
                    )
                }
            }
        }
        
        ReturnValue(C)
    }
}

Function.Matrix.MultiplyBlock {
    Input: (
        A: MatrixXf, B: MatrixXf, C: MatrixXf,
        i_start: Integer, j_start: Integer, k_start: Integer,
        block_size: Integer
    )
    Body: {
        i_end = Min(Add(i_start, block_size), A.rows)
        j_end = Min(Add(j_start, block_size), B.cols)
        k_end = Min(Add(k_start, block_size), A.cols)
        
        ForEvery i in Range(i_start, i_end) {
            ForEvery j in Range(j_start, j_end) {
                ForEvery k in Range(k_start, k_end) {
                    a_val = Matrix.Get(A, i, k)
                    b_val = Matrix.Get(B, k, j)
                    c_val = Matrix.Get(C, i, j)
                    
                    new_val = Add(c_val, Multiply(a_val, b_val))
                    Matrix.Set(C, i, j, new_val)
                }
            }
        }
    }
}

Function.Matrix.MultiplyVector {
    Input: (A: MatrixXf, v: VectorXf)
    Output: VectorXf
    Body: {
        IfCondition NotEqual(A.cols, v.size) ThenBlock {
            TryBlock: {} CatchError.DimensionMismatch {}
        }
        
        result = Vector.Create(A.rows)
        
        ForEvery i in Range(0, A.rows) {
            sum = 0.0
            ForEvery j in Range(0, A.cols) {
                a_val = Matrix.Get(A, i, j)
                sum = Add(sum, Multiply(a_val, v.data[j]))
            }
            result.data[i] = sum
        }
        
        ReturnValue(result)
    }
}

Function.Matrix.Transpose {
    Input: (A: MatrixXf)
    Output: MatrixXf
    Body: {
        result = Matrix.Create(A.cols, A.rows)
        
        // Cache-blocked transpose
        block_size = 64
        
        ForEvery i_block in Range(0, A.rows, block_size) {
            ForEvery j_block in Range(0, A.cols, block_size) {
                Matrix.TransposeBlock(A, result, i_block, j_block, block_size)
            }
        }
        
        ReturnValue(result)
    }
}

Function.Matrix.TransposeBlock {
    Input: (A: MatrixXf, result: MatrixXf, i_start: Integer, j_start: Integer, block_size: Integer)
    Body: {
        i_end = Min(Add(i_start, block_size), A.rows)
        j_end = Min(Add(j_start, block_size), A.cols)
        
        ForEvery i in Range(i_start, i_end) {
            ForEvery j in Range(j_start, j_end) {
                value = Matrix.Get(A, i, j)
                Matrix.Set(result, j, i, value)
            }
        }
    }
}

// ============================================================================
// Decomposition Algorithms
// ============================================================================

Function.Matrix.LUDecompose {
    Input: (A: MatrixXf)
    Output: Tuple[MatrixXf, MatrixXf, Array[Integer]]  // L, U, P
    Body: {
        IfCondition NotEqual(A.rows, A.cols) ThenBlock {
            TryBlock: {} CatchError.NotSquareMatrix {}
        }
        
        n = A.rows
        L = Matrix.Identity(n)
        U = Matrix.Copy(A)
        P = Array.Create(n, Integer)
        
        // Initialize permutation vector
        ForEvery i in Range(0, n) {
            P[i] = i
        }
        
        Pool.LinearAlgebra.EigenWorkspace.Allocate(workspace)
        
        ForEvery k in Range(0, Subtract(n, 1)) {
            // Find pivot
            pivot_row = Matrix.FindMaxAbsInColumn(U, k, k)
            
            // Swap rows if needed
            IfCondition NotEqual(pivot_row, k) ThenBlock {
                Matrix.SwapRows(U, k, pivot_row)
                Matrix.SwapRows(L, k, pivot_row)
                Array.Swap(P, k, pivot_row)
            }
            
            pivot_val = Matrix.Get(U, k, k)
            IfCondition LessEqual(AbsoluteValue(pivot_val), 1e-12) ThenBlock {
                TryBlock: {} CatchError.SingularMatrix {}
            }
            
            // Eliminate column
            ForEvery i in Range(Add(k, 1), n) {
                factor = Divide(Matrix.Get(U, i, k), pivot_val)
                Matrix.Set(L, i, k, factor)
                
                ForEvery j in Range(k, n) {
                    u_ik = Matrix.Get(U, i, j)
                    u_kj = Matrix.Get(U, k, j)
                    new_val = Subtract(u_ik, Multiply(factor, u_kj))
                    Matrix.Set(U, i, j, new_val)
                }
            }
        }
        
        ReturnValue(Tuple[L, U, P])
    }
}

Function.Matrix.QRDecompose {
    Input: (A: MatrixXf)
    Output: Tuple[MatrixXf, MatrixXf]  // Q, R
    Body: {
        m = A.rows
        n = A.cols
        Q = Matrix.Identity(m)
        R = Matrix.Copy(A)
        
        ForEvery k in Range(0, Min(Subtract(m, 1), n)) {
            // Generate Householder reflector
            x = Matrix.GetColumn(R, k, start_row-k)
            v = Matrix.HouseholderVector(x)
            
            // Apply reflector to R
            Matrix.ApplyHouseholderLeft(R, v, k, k)
            
            // Update Q
            Matrix.ApplyHouseholderRight(Q, v, k, k)
        }
        
        ReturnValue(Tuple[Q, R])
    }
}

Function.Matrix.CholeskyDecompose {
    Input: (A: MatrixXf)
    Output: MatrixXf  // L such that A = L * L^T
    Body: {
        IfCondition NotEqual(A.rows, A.cols) ThenBlock {
            TryBlock: {} CatchError.NotSquareMatrix {}
        }
        
        n = A.rows
        L = Matrix.Create(n, n, 0.0)
        
        ForEvery i in Range(0, n) {
            ForEvery j in Range(0, Add(i, 1)) {
                IfCondition EqualTo(i, j) ThenBlock {
                    // Diagonal element
                    sum = 0.0
                    ForEvery k in Range(0, j) {
                        l_jk = Matrix.Get(L, j, k)
                        sum = Add(sum, Multiply(l_jk, l_jk))
                    }
                    
                    a_jj = Matrix.Get(A, j, j)
                    diag_val = SquareRoot(Subtract(a_jj, sum))
                    
                    IfCondition LessEqual(diag_val, 0.0) ThenBlock {
                        TryBlock: {} CatchError.NotPositiveDefinite {}
                    }
                    
                    Matrix.Set(L, j, j, diag_val)
                } ElseBlock {
                    // Off-diagonal element
                    sum = 0.0
                    ForEvery k in Range(0, j) {
                        l_ik = Matrix.Get(L, i, k)
                        l_jk = Matrix.Get(L, j, k)
                        sum = Add(sum, Multiply(l_ik, l_jk))
                    }
                    
                    a_ij = Matrix.Get(A, i, j)
                    l_jj = Matrix.Get(L, j, j)
                    off_diag = Divide(Subtract(a_ij, sum), l_jj)
                    
                    Matrix.Set(L, i, j, off_diag)
                }
            }
        }
        
        ReturnValue(L)
    }
}

// ============================================================================
// Eigenvalue Solvers
// ============================================================================

Function.Matrix.PowerIteration {
    Input: (
        A: MatrixXf, 
        max_iterations: Integer = 1000, 
        tolerance: FloatingPoint = 1e-10
    )
    Output: Tuple[FloatingPoint, VectorXf]  // eigenvalue, eigenvector
    Body: {
        IfCondition NotEqual(A.rows, A.cols) ThenBlock {
            TryBlock: {} CatchError.NotSquareMatrix {}
        }
        
        n = A.rows
        v = Vector.Random(n)  // Random starting vector
        v = Vector.Normalize(v)
        
        lambda_old = 0.0
        
        ForEvery iteration in Range(0, max_iterations) {
            // v = A * v
            v_new = Matrix.MultiplyVector(A, v)
            
            // Estimate eigenvalue (Rayleigh quotient)
            lambda_new = Vector.Dot(v, v_new)
            
            // Normalize
            v = Vector.Normalize(v_new)
            
            // Check convergence
            error = AbsoluteValue(Subtract(lambda_new, lambda_old))
            IfCondition LessThan(error, tolerance) ThenBlock {
                ReturnValue(Tuple[lambda_new, v])
            }
            
            lambda_old = lambda_new
        }
        
        ReturnValue(Tuple[lambda_old, v])
    }
}

Function.Matrix.QRAlgorithm {
    Input: (
        A: MatrixXf, 
        max_iterations: Integer = 1000, 
        tolerance: FloatingPoint = 1e-10
    )
    Output: Array[FloatingPoint]  // All eigenvalues
    Body: {
        IfCondition NotEqual(A.rows, A.cols) ThenBlock {
            TryBlock: {} CatchError.NotSquareMatrix {}
        }
        
        // Make a copy to avoid modifying input
        Ak = Matrix.Copy(A)
        n = A.rows
        
        ForEvery iteration in Range(0, max_iterations) {
            // QR decomposition
            qr_result = Matrix.QRDecompose(Ak)
            Q = qr_result[0]
            R = qr_result[1]
            
            // A_k+1 = R * Q
            Ak_new = Matrix.Multiply(R, Q)
            
            // Check convergence (off-diagonal elements should be small)
            converged = True
            ForEvery i in Range(0, n) {
                ForEvery j in Range(0, n) {
                    IfCondition NotEqual(i, j) ThenBlock {
                        val = AbsoluteValue(Matrix.Get(Ak_new, i, j))
                        IfCondition GreaterThan(val, tolerance) ThenBlock {
                            converged = False
                        }
                    }
                }
            }
            
            Ak = Ak_new
            
            IfCondition converged ThenBlock {
                BreakLoop
            }
        }
        
        // Extract eigenvalues from diagonal
        eigenvalues = Array.Create(n, FloatingPoint)
        ForEvery i in Range(0, n) {
            eigenvalues[i] = Matrix.Get(Ak, i, i)
        }
        
        ReturnValue(eigenvalues)
    }
}

// ============================================================================
// Linear System Solvers
// ============================================================================

Function.LinearSolver.SolveLU {
    Input: (A: MatrixXf, b: VectorXf)
    Output: VectorXf
    Body: {
        // LU decomposition
        lu_result = Matrix.LUDecompose(A)
        L = lu_result[0]
        U = lu_result[1]
        P = lu_result[2]
        
        // Apply permutation to b
        b_permuted = Vector.Create(b.size)
        ForEvery i in Range(0, b.size) {
            b_permuted.data[i] = b.data[P[i]]
        }
        
        // Forward substitution: L * y = b_permuted
        y = LinearSolver.ForwardSubstitution(L, b_permuted)
        
        // Back substitution: U * x = y
        x = LinearSolver.BackSubstitution(U, y)
        
        ReturnValue(x)
    }
}

Function.LinearSolver.ForwardSubstitution {
    Input: (L: MatrixXf, b: VectorXf)
    Output: VectorXf
    Body: {
        n = L.rows
        y = Vector.Create(n)
        
        ForEvery i in Range(0, n) {
            sum = 0.0
            ForEvery j in Range(0, i) {
                l_ij = Matrix.Get(L, i, j)
                sum = Add(sum, Multiply(l_ij, y.data[j]))
            }
            
            l_ii = Matrix.Get(L, i, i)
            y.data[i] = Divide(Subtract(b.data[i], sum), l_ii)
        }
        
        ReturnValue(y)
    }
}

Function.LinearSolver.BackSubstitution {
    Input: (U: MatrixXf, y: VectorXf)
    Output: VectorXf
    Body: {
        n = U.rows
        x = Vector.Create(n)
        
        ForEvery i in Range(Subtract(n, 1), -1, -1) {
            sum = 0.0
            ForEvery j in Range(Add(i, 1), n) {
                u_ij = Matrix.Get(U, i, j)
                sum = Add(sum, Multiply(u_ij, x.data[j]))
            }
            
            u_ii = Matrix.Get(U, i, i)
            x.data[i] = Divide(Subtract(y.data[i], sum), u_ii)
        }
        
        ReturnValue(x)
    }
}

Function.LinearSolver.ConjugateGradient {
    Input: (
        A: MatrixXf, 
        b: VectorXf, 
        x0: VectorXf,
        max_iterations: Integer = 1000,
        tolerance: FloatingPoint = 1e-6
    )
    Output: VectorXf
    Body: {
        x = Vector.Copy(x0)
        r = Vector.Subtract(b, Matrix.MultiplyVector(A, x))
        p = Vector.Copy(r)
        
        ForEvery k in Range(0, max_iterations) {
            Ap = Matrix.MultiplyVector(A, p)
            
            r_dot_r = Vector.Dot(r, r)
            alpha = Divide(r_dot_r, Vector.Dot(p, Ap))
            
            // Update x and r
            x = Vector.Add(x, Vector.Scale(p, alpha))
            r_new = Vector.Subtract(r, Vector.Scale(Ap, alpha))
            
            // Check convergence
            residual_norm = SquareRoot(Vector.Dot(r_new, r_new))
            IfCondition LessThan(residual_norm, tolerance) ThenBlock {
                ReturnValue(x)
            }
            
            // Update p
            r_new_dot_r_new = Vector.Dot(r_new, r_new)
            beta = Divide(r_new_dot_r_new, r_dot_r)
            p = Vector.Add(r_new, Vector.Scale(p, beta))
            
            r = r_new
        }
        
        ReturnValue(x)
    }
}

// ============================================================================
// Utility Functions
// ============================================================================

Function.Matrix.Copy {
    Input: (A: MatrixXf)
    Output: MatrixXf
    Body: {
        result = Matrix.Create(A.rows, A.cols)
        total_size = Multiply(A.rows, A.cols)
        
        ForEvery i in Range(0, total_size) {
            result.data[i] = A.data[i]
        }
        
        ReturnValue(result)
    }
}

Function.Vector.Copy {
    Input: (v: VectorXf)
    Output: VectorXf
    Body: {
        result = Vector.Create(v.size)
        
        ForEvery i in Range(0, v.size) {
            result.data[i] = v.data[i]
        }
        
        ReturnValue(result)
    }
}

Function.Vector.Random {
    Input: (size: Integer)
    Output: VectorXf
    Body: {
        result = Vector.Create(size)
        
        ForEvery i in Range(0, size) {
            // Simple random number generation (can be improved)
            result.data[i] = Subtract(Multiply(Random(), 2.0), 1.0)
        }
        
        ReturnValue(result)
    }
}

Function.Vector.Subtract {
    Input: (a: VectorXf, b: VectorXf)
    Output: VectorXf
    Body: {
        IfCondition NotEqual(a.size, b.size) ThenBlock {
            TryBlock: {} CatchError.DimensionMismatch {}
        }
        
        result = Vector.Create(a.size)
        
        ForEvery i in Range(0, a.size) {
            result.data[i] = Subtract(a.data[i], b.data[i])
        }
        
        ReturnValue(result)
    }
}

Function.Matrix.FindMaxAbsInColumn {
    Input: (A: MatrixXf, col: Integer, start_row: Integer)
    Output: Integer
    Body: {
        max_val = 0.0
        max_row = start_row
        
        ForEvery i in Range(start_row, A.rows) {
            val = AbsoluteValue(Matrix.Get(A, i, col))
            IfCondition GreaterThan(val, max_val) ThenBlock {
                max_val = val
                max_row = i
            }
        }
        
        ReturnValue(max_row)
    }
}

Function.Matrix.SwapRows {
    Input: (A: MatrixXf, row1: Integer, row2: Integer)
    Body: {
        ForEvery j in Range(0, A.cols) {
            val1 = Matrix.Get(A, row1, j)
            val2 = Matrix.Get(A, row2, j)
            Matrix.Set(A, row1, j, val2)
            Matrix.Set(A, row2, j, val1)
        }
    }
}

// ============================================================================
// Performance Monitoring
// ============================================================================

Function.Performance.BeginLinearAlgebraOperation {
    Input: (operation_name: Text, matrix_size: Integer)
    Body: {
        Cache.L1.BeginMonitoring()
        Cache.L2.BeginMonitoring()
        Cache.L3.BeginMonitoring()
        Memory.BeginBandwidthMonitoring()
        
        PrintMessage("Starting " + operation_name + " with size " + ToString(matrix_size))
    }
}

Function.Performance.EndLinearAlgebraOperation {
    Input: (operation_name: Text)
    Output: PerformanceStats
    Body: {
        stats = PerformanceStats.Create()
        stats.operation_name = operation_name
        stats.l1_hit_rate = Cache.L1.GetHitRate()
        stats.l2_hit_rate = Cache.L2.GetHitRate()
        stats.l3_hit_rate = Cache.L3.GetHitRate()
        stats.memory_bandwidth = Memory.GetBandwidthUtilization()
        stats.flops = Performance.GetFLOPS()
        
        PrintMessage("Completed " + operation_name)
        PrintMessage("L1 Hit Rate: " + ToString(stats.l1_hit_rate))
        PrintMessage("Memory Bandwidth: " + ToString(stats.memory_bandwidth))
        
        ReturnValue(stats)
    }
}